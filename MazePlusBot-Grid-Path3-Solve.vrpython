{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\ndown_eye = EyeSensor(\"downeye\", 5)\nfront_distance = Distance(\"frontdistance\", 2)\ndistance = front_distance\nleft_distance = Distance(\"leftdistance\", 3)\nright_distance = Distance(\"rightdistance\", 4)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcdrivetrain.turn_to_heading(90, DEGREES)\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n# Add project code in \"main\"\n\nimport sys\nimport gc\nfrom enum import Enum\nfrom queue import PriorityQueue\n\nclass CMazePath:\n    def __init__(self, prevNode, thisLoc):\n        self._thisLoc = thisLoc\n        self._cost = -1\n        self._prevNode = prevNode\n        self._nextNodes = [None, None, None]\n\n    def __del__(self):\n        brain.print(\"delete path node\")\n        brain.new_line()\n#end class\n\ndef PathAppend(prevNode, nextLocs):\n    if prevNode == None:\n        return [None, None, None]\n    if prevNode._nextNodes[0] == None and prevNode._nextNodes[1] == None and prevNode._nextNodes[2] == None:\n        pass\n    else:\n        return prevNode._nextNodes\n    for i in range(0, 3):\n        if nextLocs[i] != None:\n            tempGrid = GetGridFromLocation(nextLocs[i])\n            if not tempGrid._isvalid:\n                nextNode = CMazePath(prevNode, nextLocs[i])\n                prevNode._nextNodes[i] = nextNode\n\n    return prevNode._nextNodes\n\ndef PathPrune(parent, child):\n    idx = parent._nextNodes.index(child)\n    parent._nextNodes[idx] = None\n    brain.print(\"removing node:\", child._thisLoc, child)\n    brain.new_line()\n    del child\n\ndef DeletePath(node):\n    # TODO:\n    pass\n\ndef PrintPath(node, level = 0):\n    if node == None: return\n    if node._prevNode == None:\n        brain.print(\"PP\", level, \": \", \"None\", \" \", node._thisLoc, \" \", node._nextNodes)\n    else:\n        brain.print(\"PP\", level, \": \", node._prevNode._thisLoc, \" \", node._thisLoc, \" \", node._nextNodes)\n    brain.new_line()\n    level = level + 1\n    for nextNode in node._nextNodes:\n        if nextNode != None:\n            # for some reason does not work if on same line\n            PrintPath(nextNode, level)\n\nclass CMazePoint:\n    def __init__(self, row, col):\n        self._row = row\n        self._col = col\n        self._x = 0\n        self._y = 0\n        self._isvalid = False\n        self._isblocked = False\n    \n    def SetLocation(self, x, y):\n        self._x = x\n        self._y = y\n        self._isvalid = True\n\n    def SetValid(self):\n        self._isvalid = True\n\n    def SetBlocked(self):\n        self._isblocked = True\n# end class\n\n# enum for robot actions\nclass ETurnTo(Enum):\n    EFORWARD = 0\n    ERIGHT = 1\n    EBACKWARDS = 2\n    ELEFT = 3\n\n# distance sensors are mapped (left, right, front) in tuples\nSensorMapping = [ETurnTo.ELEFT, ETurnTo.ERIGHT, ETurnTo.EFORWARD]\n\n# enum for actual direction in maze (coords used is robot starts at 0,0 and N is +x E is +y) \nclass EHeading(Enum):\n    ENORTH = 0\n    EEAST = 1\n    ESOUTH = 2\n    EWEST = 3\n    UNDEF = 4\n\n# X stored in ROWS, Y stored in COLS\n# TODO: Extents checking\nMAZEROWS = 20\nMAZECOLS = 20\nmaze2D = []\n\nrobotLocation = (0, 0)\ncurrentHeading = EHeading.ENORTH\norigin = (0, 0)\ngoal = None\nminExtent = (0, 0)\nmaxExtent = (0, 0)\n\ndef InitGrid():\n    global maze2D\n    maze2D = [[CMazePoint(i, j) for j in range(MAZECOLS)] for i in range(MAZEROWS)]\n\ndef LocationToGrid(loc):\n    grid_row = (MAZEROWS + loc[0]) % MAZEROWS\n    grid_col = (MAZECOLS + loc[1]) % MAZECOLS\n    return((grid_row, grid_col))\n\ndef GetGridFromLocation(loc):\n    global maze2D\n    gridIdx = LocationToGrid(loc)\n    gridPoint = maze2D[gridIdx[0]][gridIdx[1]]\n    return gridPoint\n\ndef UpdateGrid(loc):\n    global minExtent\n    global maxExtent\n\n    gridPoint = GetGridFromLocation(loc)\n    if (gridPoint._isvalid):\n        return\n    gridPoint.SetLocation(loc[0], loc[1])\n\n    if (loc[0] < minExtent[0]): minExtent = (loc[0], minExtent[1])\n    elif (loc[0] > maxExtent[0]): maxExtent = (loc[0], maxExtent[1])\n    if (loc[1] < minExtent[1]): minExtent = (minExtent[0], loc[1])\n    elif (loc[1] > maxExtent[1]): maxExtent = (maxExtent[0], loc[1])\n\ndef GetGridPointFromTurn(robotLocation, currentHeading, turnDir):\n    tempHeading = HeadingFromDirection(currentHeading, turnDir)\n    tempLocation =  LocationFromHeading(robotLocation, tempHeading)\n    tempGrid = GetGridFromLocation(tempLocation)\n    return tempGrid\n\ndef GetNextNotVisitedNode(nextNodes):\n    #brain.print(\"GetNextNotVisitedNode\", nextNodes)\n    #brain.new_line()\n    selectedNode = None\n    for node in nextNodes:\n        if node != None:\n            tempGrid = GetGridFromLocation(node._thisLoc)\n            if not tempGrid._isvalid:\n                selectedNode = node\n                break\n    return selectedNode\n\ndef LoadMaze(savedMaze):\n    global maze2D\n    global origin\n    global goal\n    global robotLocation\n\n    j = MAZECOLS - 1\n    i = 0\n\n    for char in savedMaze:\n        newline = True if ((ord(char)) == 10) else False\n        if not newline and char != \".\":\n            maze2D[i][j]._x = i\n            maze2D[i][j]._y = j\n            maze2D[i][j]._isvalid = True\n            if char == \"x\" or char == \"X\":\n                pass\n            elif char == \"d\" or char == \"D\":\n                maze2D[i][j]._isblocked = True\n            elif char == \"o\" or char == \"O\":\n                origin = (i, j)\n                robotLocation = origin\n            elif char == \"g\" or char == \"G\":\n                goal = (i, j)\n        if newline:\n            if i == 0:\n                # blank line\n                pass\n            else:\n                j = j - 1\n            i = 0\n        else:\n            i = i + 1\n\n    UpdateExtents()\n\ndef PrintGrid():\n    # TODO: modulate with X/Y extents\n    brain.new_line()\n    for c in range(MAZECOLS):\n        for r in range(MAZEROWS):\n            j = (MAZECOLS + ((MAZECOLS - 1) - c + minExtent[1])) % MAZECOLS\n            i = (MAZEROWS + (r + minExtent[0])) % MAZEROWS\n            if maze2D[i][j]._isvalid:\n                if maze2D[i][j]._x == origin[0] and maze2D[i][j]._y == origin[1]: brain.print(\"o\")\n                elif goal != None and maze2D[i][j]._x == goal[0] and maze2D[i][j]._y == goal[1]: brain.print(\"g\")\n                elif maze2D[i][j]._isblocked: brain.print(\"D\")\n                else: brain.print(\"x\")\n            else: brain.print(\".\")\n        brain.new_line()\n    brain.new_line()\n\n# relative to current robot heading\ndef PickRandDirection(gaps, visited = (False, False, False)):\n    # use choice() to pick from valid list of options\n    pickList = []\n    if gaps[0]: pickList.append(ETurnTo.ELEFT)\n    if gaps[1]: pickList.append(ETurnTo.ERIGHT)\n    if gaps[2]: pickList.append(ETurnTo.EFORWARD)\n\n    # dead end (0 options exist)\n    if len(pickList) == 0:\n        pickDir = ETurnTo.EBACKWARDS\n        return pickDir\n    \n    # straight or bend (1 option exists)\n    if len(pickList) == 1:\n        pickDir = pickList[0];\n        return pickDir\n\n    # junction (2 or 3 options exist)\n    numVisited = 0;\n    if visited[0]: numVisited = numVisited + 1\n    if visited[1]: numVisited = numVisited + 1\n    if visited[2]: numVisited = numVisited + 1\n\n    # if none or all branches have already been taken\n    if numVisited == 0 or numVisited == len(pickList):\n        pickDir = random.choice(pickList)\n        return pickDir\n\n    brain.print(\"pruning\")\n    brain.new_line()\n    pickList = []\n    if gaps[0] and not visited[0]: pickList.append(ETurnTo.ELEFT)\n    if gaps[1] and not visited[1]: pickList.append(ETurnTo.ERIGHT)\n    if gaps[2] and not visited[2]: pickList.append(ETurnTo.EFORWARD)\n    pickDir = random.choice(pickList)\n    return pickDir\n\ndef CheckVisited(robotLocation, currentHeading, dirs):\n    visited = [False, False, False]\n    for i in range(0, len(dirs)):\n        if (dirs[i]):\n            tempGrid = GetGridPointFromTurn(robotLocation, currentHeading, SensorMapping[i])\n            if tempGrid._isvalid: visited[i] = True\n    retval = (visited[0], visited[1], visited[2])\n    return retval\n\ndef PruneBlocked(robotLocation, currentHeading, dirs):\n    blocked = [False, False, False]\n    for i in range(0, len(dirs)):\n        if (dirs[i]):\n            tempGrid = GetGridPointFromTurn(robotLocation, currentHeading, SensorMapping[i])\n            if tempGrid._isblocked: blocked[i] = True\n\n    if (blocked[0] or blocked[1] or blocked[2]):\n        brain.print(\"blocked\")\n        brain.new_line()\n\n    retval = (dirs[0] and not blocked[0], dirs[1] and not blocked[1], dirs[2] and not blocked[2])\n    return retval\n\n# convert robot-centric to field N-S-E-W heading\ndef HeadingFromDirection(currentHeading, nextDirection):\n    intHeading = (currentHeading.value + nextDirection.value) % 4\n    newHeading = EHeading(intHeading)\n    return newHeading\n\n# convert robot-centric to field N-S-E-W heading\ndef DirectionFromHeading(currentHeading, nextHeading):\n    intDirection = (4 + nextHeading.value - currentHeading.value) % 4\n    newDirection = ETurnTo(intDirection)\n    return newDirection\n\n# gets the next X/Y location based on field heading\ndef LocationFromHeading(curLocation, robotHeading):\n    if (robotHeading == EHeading.ENORTH): thisMove = (0, 1)\n    elif (robotHeading == EHeading.ESOUTH): thisMove = (0, -1)\n    elif (robotHeading == EHeading.EEAST): thisMove = (1, 0)\n    elif (robotHeading == EHeading.EWEST): thisMove = (-1, 0)\n    newLocation = (curLocation[0] + thisMove[0], curLocation[1] + thisMove[1])\n    return newLocation\n\n# gets next X/Y location from current location given robot heading (N-S-E-W) and robot relative turn (L-R-F)\ndef LocationFromDirection(currentLocation, currentHeading, nextDirection):\n    nextHeading = HeadingFromDirection(currentHeading, nextDirection)\n    nextLocation = LocationFromHeading(currentLocation, nextHeading)\n    return nextLocation\n\n# takes sensor tuple and checks if 2 or more options are available\ndef IsJunction(dirs):\n    count = 0\n    if dirs[0]: count = count + 1\n    if dirs[1]: count = count + 1\n    if dirs[2]: count = count + 1\n    return count > 1\n\n# takes sensor tuple and checks if no options are available\ndef IsBlocked(dirs):\n    count = 0\n    if dirs[0]: count = count + 1\n    if dirs[1]: count = count + 1\n    if dirs[2]: count = count + 1\n    if count == 0:\n        return True\n    else:\n        return False\n\n# junction stored in tree\ndef IsPathJunction(node):\n    if node == None:\n        Assert(False)\n    count = 0\n    for nn in node._nextNodes:\n        if nn != None:\n            count = count + 1\n\n# gets adjoining cell X/Y coordinates based on robot location, heading and L-R-F turn options\ndef DirectionsToLocations(loc, head, dirs):\n    nextLocs = []\n    for i in range(0, len(dirs)):\n        if (dirs[i]):\n            tempLoc = LocationFromDirection(loc, head, SensorMapping[i])\n            nextLocs.append(tempLoc)\n        else:\n            nextLocs.append(None)\n    return nextLocs\n\ndef NextLocationToTurn(currentLocation, nextLocation, robotHeading):\n    if currentLocation[0] < nextLocation[0]: nextHeading = EHeading.EEAST\n    elif currentLocation[0] > nextLocation[0]: nextHeading = EHeading.EWEST\n    elif currentLocation[1] < nextLocation[1]: nextHeading = EHeading.ENORTH\n    elif currentLocation[1] > nextLocation[1]: nextHeading = EHeading.ESOUTH\n    else:\n        nextHeading = EHeading.ENORTH\n\n    headingDelta = (4 + nextHeading.value - robotHeading.value) % 4\n    nextTurn = ETurnTo(headingDelta)\n\n    return nextTurn\n\nclass EPathState(Enum):\n    EHOME = 0\n    ESEARCH = 1\n    EDEADEND = 2\n    EBACKTRACK = 3\n\ndef DiscoverMaze():\n    global robotLocation\n    global currentHeading\n    global goal\n\n    brain.print(\"Discovering maze ...\")\n    brain.new_line()\n\n    path = CMazePath(None, robotLocation)\n    currentNode = path\n\n    currentHeading = EHeading.ENORTH\n    lastLocation = None\n    # bBackTrack = False\n    bDeadEnd = False\n    bGoalPath = False\n\n    done = False\n    currentState = EPathState.ESEARCH\n    \n    while not done:\n        brain.new_line()\n        brain.print(\"--- start: \", robotLocation, \", \", currentHeading)\n        brain.new_line()\n\n        # squares are 300mm, but current robot has 0 width, so pick something between 150 and 300\n        bLeftGap = left_distance.get_distance(MM) > 225\n        bRightGap = right_distance.get_distance(MM) > 225\n        bFrontGap = front_distance.get_distance(MM) > 225\n        gaps = (bLeftGap, bRightGap, bFrontGap)\n\n        # generate some trivial bools based on what distance sensors see\n        # dead-end is sticky until the parent junction is reached so path can be trivially rejected in the future\n        # TODO: don't reject forks with the goal or origin\n        # TODO: only flags trivial case of leaf paths. dead-end paths with forks could be flagged as well\n        bJunction = IsJunction(gaps)\n        bBlocked = IsBlocked(gaps)\n        # based on sensors, determine adjoining X/Y locations and then see if we have any new paths\n        # TODO: Once we have known paths, could just steer directly this way and sanity checkw with sensors\n        nextLocations = DirectionsToLocations(robotLocation, currentHeading, gaps)\n\n        if not bGoalPath and not bDeadEnd and bBlocked:\n            brain.print(\"dead-end\")\n            brain.new_line()\n            bDeadEnd = True\n        if bJunction: bGoalPath = False\n\n        if currentState == EPathState.ESEARCH:\n            brain.print(\"SEARCH\")\n            brain.new_line()\n            nextNodes = PathAppend(currentNode, nextLocations)\n            brain.print(nextNodes)\n            brain.new_line()\n            selectedNode = GetNextNotVisitedNode(nextNodes)\n            if selectedNode != None:\n                brain.print(\"--NEW SEARCH\", selectedNode._thisLoc)\n                brain.new_line()\n                nextTurn = NextLocationToTurn(robotLocation, selectedNode._thisLoc, currentHeading)\n                nextNode = selectedNode\n                nextState = EPathState.ESEARCH\n            else:\n                brain.print(\"--END SEARCH\")\n                brain.new_line()\n                nextTurn = ETurnTo.EBACKWARDS\n                nextNode = currentNode._prevNode\n                nextState = EPathState.EBACKTRACK\n                PathPrune(nextNode, currentNode)\n\n        elif currentState == EPathState.EBACKTRACK:\n            brain.print(\"BACKTRACK\")\n            brain.new_line()\n            prevNode = currentNode._prevNode\n            bPathTaken = False\n            if currentNode != None:\n                selectedNode = GetNextNotVisitedNode(currentNode._nextNodes)\n                if selectedNode != None:\n                    brain.print(\"--NEW SEARCH\", selectedNode._thisLoc)\n                    brain.new_line()\n                    nextTurn = NextLocationToTurn(robotLocation, selectedNode._thisLoc, currentHeading)\n                    nextNode = selectedNode\n                    nextState = EPathState.ESEARCH\n                    bPathTaken = True\n                elif prevNode != None:\n                    brain.print(\"--CONTINUE BACK\")\n                    brain.new_line()\n                    prevNode = currentNode._prevNode\n                    nextTurn = NextLocationToTurn(robotLocation, prevNode._thisLoc, currentHeading)\n                    nextNode = prevNode\n                    nextState = EPathState.EBACKTRACK\n                    PathPrune(nextNode, currentNode)\n                    bPathTaken = True\n                else:\n                    nextNodes = PathAppend(currentNode, nextLocations)\n                    brain.print(nextNodes)\n                    brain.new_line()\n                    selectedNode = GetNextNotVisitedNode(nextNodes)\n                    if selectedNode != None:\n                        brain.print(\"--NEW SEARCH\", selectedNode._thisLoc)\n                        brain.new_line()\n                        nextTurn = NextLocationToTurn(robotLocation, selectedNode._thisLoc, currentHeading)\n                        nextNode = selectedNode\n                        nextState = EPathState.ESEARCH\n                        bPathTaken = True\n                        bDeadEnd = False\n\n            else:\n                brain.print(\"at path root\")\n                brain.new_line()                \n\n            if not bPathTaken:\n                brain.print(\"--AT HOME\")\n                brain.new_line()\n                PrintPath(path)\n                nextTurn = ETurnTo.EBACKWARDS\n                nextState = EPathState.EHOME\n                done = True\n\n            if bJunction:\n                pass\n            else:\n                pass\n\n        elif currentState == EPathState.EHOME:\n            brain.print(\"HOME\")\n            brain.new_line()\n\n        else:\n            pass\n\n        currentNode = nextNode\n        currentState = nextState\n\n        nextHeading = HeadingFromDirection(currentHeading, nextTurn)\n\n        if nextTurn == ETurnTo.ELEFT: drivetrain.turn_for(LEFT,90,DEGREES)\n        elif nextTurn == ETurnTo.ERIGHT: drivetrain.turn_for(RIGHT,90,DEGREES)\n        elif nextTurn == ETurnTo.EBACKWARDS: drivetrain.turn_for(LEFT,180,DEGREES)\n        else: pass # go forward   \n        currentHeading = nextHeading\n        \n        if not done:\n            drivetrain.drive_for(FORWARD,300,MM)\n\n            # update location, heading etc.\n            # if not bBackTrack and nextTurn == ETurnTo.EBACKWARDS: bBackTrack = True\n            if bJunction and bDeadEnd:\n                bDeadEnd = False\n            if bDeadEnd:\n                brain.print(\"mark dead-end @\", robotLocation)\n                brain.new_line()\n                gridPoint = GetGridFromLocation(robotLocation)\n                gridPoint.SetBlocked()\n\n            lastLocation = robotLocation\n            robotLocation = LocationFromHeading(robotLocation, currentHeading)\n            UpdateGrid(robotLocation)\n\n        if goal == None and down_eye.detect(RED):\n            goal = robotLocation\n            brain.print(\"GOAL FOUND: \", goal)\n            brain.new_line()\n            PrintGrid()\n            bGoalPath = True\n\n    del path\n    path = None\n    gc.collect()\n\n    brain.print(\"Discover Maze Done\")\n    brain.new_line()\n    wait(1,SECONDS)\n\n\ndef DiscoverMazeRandom():\n    global path\n    global robotLocation\n    global goal\n\n    brain.print(\"Discovering maze ...\")\n    brain.new_line()\n\n    currentHeading = EHeading.ENORTH\n    lastLocation = None\n    bDeadEnd = False\n\n    done = False\n    \n    while not done:\n        # squares are 300mm, but current robot has 0 width, so pick something between 150 and 300\n        bLeftGap = left_distance.get_distance(MM) > 225\n        bRightGap = right_distance.get_distance(MM) > 225\n        bFrontGap = front_distance.get_distance(MM) > 225\n        gaps = (bLeftGap, bRightGap, bFrontGap)\n\n        gaps = PruneBlocked(robotLocation, currentHeading, gaps)\n        visited = (False, False, False)\n\n        bJunction = IsJunction(gaps)\n        if bJunction:\n            visited = CheckVisited(robotLocation, currentHeading, gaps)\n\n        nextDir = PickRandDirection(gaps, visited)\n        nextHeading = HeadingFromDirection(currentHeading, nextDir)\n\n        if nextDir == ETurnTo.ELEFT: drivetrain.turn_for(LEFT,90,DEGREES)\n        elif nextDir == ETurnTo.ERIGHT: drivetrain.turn_for(RIGHT,90,DEGREES)\n        elif nextDir == ETurnTo.EBACKWARDS: drivetrain.turn_for(LEFT,180,DEGREES)\n        else: pass # go forward   \n        currentHeading = nextHeading\n        \n        if not bDeadEnd and nextDir == ETurnTo.EBACKWARDS: bDeadEnd = True\n        if bJunction and bDeadEnd:\n            gridPoint = GetGridFromLocation(lastLocation)\n            gridPoint.SetBlocked()\n            bDeadEnd = False\n\n        drivetrain.drive_for(FORWARD,300,MM)\n\n        lastLocation = robotLocation\n        robotLocation = LocationFromHeading(robotLocation, currentHeading)\n        UpdateGrid(robotLocation)\n\n        if down_eye.detect(RED):\n            goal = robotLocation\n            done = True\n\ndef ValidActions(valids, qx, qy):\n    valid_actions = []\n    xsize = len(valids)\n    ysize = len(valids[0])\n    if qx < xsize - 1:\n        if valids[qx+1][qy]:\n            valid_actions.append(((qx+1, qy), EHeading.EEAST.value))\n    if qy < ysize - 1:\n        if valids[qx][qy+1]:\n            valid_actions.append(((qx, qy+1), EHeading.ENORTH.value))\n    if qx > 0:\n        if valids[qx-1][qy]:\n            valid_actions.append(((qx-1, qy), EHeading.EWEST.value))\n    if qy > 0:\n        if valids[qx][qy-1]:\n            valid_actions.append(((qx, qy-1), EHeading.ESOUTH.value))\n    return valid_actions\n\ndef UpdateExtents():\n    global minExtent\n    global maxExtent\n\n    minExtent = (0, 0)\n    maxExtent = (0, 0)\n\n    for i in range(MAZEROWS):\n        for j in range(MAZECOLS):\n            if maze2D[i][j]._isvalid:\n                x, y = maze2D[i][j]._x, maze2D[i][j]._y\n                if x > maxExtent[0]: maxExtent = (x, maxExtent[1])\n                if y > maxExtent[1]: maxExtent = (maxExtent[0], y)\n                if x < minExtent[0]: minExtent = (x, minExtent[1])\n                if y < minExtent[1]: minExtent = (minExtent[0], y)\n\n    brain.print(\"Extents: \", minExtent, maxExtent)\n    brain.new_line()\n\ndef ReverseOptimize(valids):\n    # start at goal and trace back to origin\n    # stores location, cost in distance and turns\n\n    if goal == None: return\n\n    mazeSize = (len(valids), len(valids[0]))\n    goal_norm = (goal[0] - minExtent[0], goal[1] - minExtent[1])\n    origin_norm = (origin[0] - minExtent[0], origin[1] - minExtent[1])\n\n    visited = [[False for j in range(mazeSize[1])] for i in range(mazeSize[0])]\n    costs = [[-1 for j in range(mazeSize[1])] for i in range(mazeSize[0])]\n\n    visitlist = set(goal_norm)\n    queue = PriorityQueue()\n    queue.put((0, goal_norm, EHeading.UNDEF.value))\n    max_cost = 1\n\n    while not queue.empty():\n        item = queue.get()\n        queue_cost = item[0]\n        queue_loc = item[1]\n        queue_head = item[2]\n        qx, qy = queue_loc[0], queue_loc[1]\n        # TODO: Add check if got visited by the time we got here\n        if visited[qx][qy]:\n            if costs[qx][qy] > queue_cost:\n                costs[qx][qy] = queue_cost\n        else:\n            costs[qx][qy] = queue_cost\n        visited[qx][qy] = True\n        \n        valid_actions = ValidActions(valids, qx, qy)\n\n        if queue_cost > max_cost:\n            max_cost = queue_cost\n        if queue_head == EHeading.UNDEF.value:\n            first_action = valid_actions[0]\n            queue_head = first_action[1]\n        for va in valid_actions:\n            loc = va[0]\n            head = va[1]\n            if visited[loc[0]][loc[1]]:\n                continue\n            turn_cost = 0 if queue_head == head else 2\n            # turn_cost = 0\n            next_cost = queue_cost + 1 + turn_cost\n            brain.print(next_cost, loc, EHeading(head))\n            brain.new_line()\n            queue.put((next_cost, loc, head))\n\n        if False:\n            brain.new_line()\n            for y in range(mazeSize[1] - 1, -1, -1):\n                for x in range(mazeSize[0]):\n                    if visited[x][y]: brain.print(\"x\")\n                    else: brain.print(\".\")\n                brain.new_line()\n\n    if True:\n        brain.new_line()\n        for y in range(mazeSize[1] - 1, -1, -1):\n            for x in range(mazeSize[0]):\n                if costs[x][y] >= 0:\n                    dc = int(costs[x][y] * 9 / max_cost)\n                    brain.print(dc)\n                else: brain.print(\".\")\n            brain.new_line()\n\n    path = []\n    current_loc = origin_norm\n    current_cost = costs[current_loc[0]][current_loc[1]]\n    path.append(origin_norm)\n    bAbort = False\n    while not bAbort and (current_loc != goal_norm):\n        next_loc = loc\n        next_cost = current_cost\n        valid_actions = ValidActions(valids, current_loc[0], current_loc[1])\n        bAbort = True\n        for va in valid_actions:\n            loc = va[0]\n            if costs[loc[0]][loc[1]] < next_cost:\n                next_loc = loc\n                next_cost = costs[loc[0]][loc[1]] \n                bAbort = False\n        if not bAbort:\n            current_loc = next_loc\n            current_cost = next_cost\n            path.append(current_loc)\n\n    if bAbort:\n        brain.print(\"ABORTED SEARCH\")\n        brain.new_line()\n        path = None\n    brain.new_line()\n    brain.print(\"Steps\", len(path))\n    brain.new_line()\n    brain.print(path)\n    brain.new_line()\n\n    return path\n\ndef GenerateInstructions(path):\n\n    if path == None: return None\n\n    instructions = []\n    last_heading = EHeading.UNDEF\n    this_heading = EHeading.UNDEF\n    step_count = 1\n    last_point = None\n    for point in path:\n        if last_point != None:\n            if point[0] > last_point[0]: this_heading = EHeading.EEAST\n            elif point[0] < last_point[0]: this_heading = EHeading.EWEST\n            elif point[1] > last_point[1]: this_heading = EHeading.ENORTH\n            elif point[1] < last_point[1]: this_heading = EHeading.ESOUTH\n\n            if last_heading != EHeading.UNDEF:\n                if this_heading != last_heading:\n                    instructions.append((step_count, last_heading))\n                    step_count = 1\n                else:\n                    step_count = step_count + 1\n\n            last_heading = this_heading\n\n        last_point = point\n\n    instructions.append((step_count, last_heading))\n\n    brain.print(instructions)\n    brain.new_line()\n\n    return instructions\n\nsavedMaze1 = \"\"\"\n....................\n....................\n....................\n....................\n....................\n..........xxx.g.....\nDDDDDD....x.x.x.....\n.....D..xxx.xxx.....\n..DDDD..x...x.......\n..D.....x...x.......\nDDD..xxxxx..x.......\nD....x.x.xxxxx......\nD....x.x.D...x......\nD..xxx.x.D...x......\nDDDx...x.DDD.x......\n...x...x.....x......\nxxxxxx.x.....x......\nx.D..xxxxxxxxx......\nx.D..D.....x.x......\no.D..DDDD..xxx......\n\"\"\"\n\nsavedMaze2 = \"\"\"\n....................\n....................\n....................\n....................\n....................\n....................\n....................\n....................\n....................\nDDD.................\n..xD................\nDDx.................\n..x.................\n..x.................\nxxxxx...............\nx...xgDD............\nx...................\nxxx.................\n..xD................\noxx.................\n\"\"\"\n\ndef main():\n    global robotLocation\n    global currentHeading\n    global origin\n    global goal\n    global minExtent\n    global maxExtent\n\n    brain.clear()\n    brain.print(\"hello, ver\", sys.version)\n    brain.new_line()\n    brain.new_line()    \n\n    InitGrid()\n    PrintGrid()\n\n    savedMaze = None\n\n    if savedMaze == None:\n        UpdateGrid(robotLocation)\n        DiscoverMaze()\n        brain.new_line()\n        brain.print(\"Discovered Maze: origin \", origin, \", goal \", goal, \", loc \", robotLocation)\n        brain.new_line()\n        PrintGrid()\n    else:\n        LoadMaze(savedMaze)\n        brain.new_line()\n        brain.print(\"Saved Maze: origin \", origin, \", goal \", goal, \", loc \", robotLocation)\n        brain.new_line()\n        PrintGrid()\n\n    # followed structures used normalized to 0, 0 coordinates. original maze will not be normalized\n\n    # UpdateExtents()\n    \n    mazeSize = (maxExtent[0] - minExtent[0] + 1, maxExtent[1] - minExtent[1] + 1)\n    valids = [[False for j in range(mazeSize[1])] for i in range(mazeSize[0])]\n\n    for i in range(MAZEROWS):\n        for j in range(MAZECOLS):\n            if maze2D[i][j]._isvalid and not maze2D[i][j]._isblocked:\n                # maze used for discovery is not normalized\n                x, y = maze2D[i][j]._x - minExtent[0], maze2D[i][j]._y - minExtent[1]\n                valids[x][y] = True\n\n    path = ReverseOptimize(valids)\n    instructions = GenerateInstructions(path)\n\n    if instructions == None: return\n\n    brain.print(\"Following instructions ...\", currentHeading)\n    brain.new_line()\n\n    for instr in instructions:\n        nextHeading = instr[1]\n        steps = instr[0]\n        nextDir = DirectionFromHeading(currentHeading, nextHeading)\n        if nextDir == ETurnTo.ELEFT: drivetrain.turn_for(LEFT,90,DEGREES)\n        elif nextDir == ETurnTo.ERIGHT: drivetrain.turn_for(RIGHT,90,DEGREES)\n        elif nextDir == ETurnTo.EBACKWARDS: drivetrain.turn_for(LEFT,180,DEGREES)\n        else: pass # go forward   \n        currentHeading = nextHeading\n        drivetrain.drive_for(FORWARD,steps*300,MM)\n\n# VR threads â€” Do not delete\nvr_thread(main)\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"PG","sdkVersion":"20220726.10.00.00","appVersion":"3.0.5","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"MazePlus","robotModel":"vrEnhMaze","mazeData":{"mazeData":"222222222222222222111111111111111221222222122222212212111111112112122121222222222121221212111111121212212121222221211122322212111212221221211121012111212212122212121222122121211122212111221212221111121212212122222222212122121111111121121221222222122222212211111111111111122222222222222222219"},"target":"Physical"}